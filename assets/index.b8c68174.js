import{r as n,o as e,c as o,a as i,V as t,T as r,C as c,b as s,F as v,w as x,d as a,e as p,f as l,g as d,h as y,_ as u}from"./vendor.e9ee9bd7.js";const m={};m.render=function(t,r,c,s,v,x){const a=n("router-view");return e(),o("div",null,[i(a)])};const z="\n       vec4 permute(vec4 x){return mod(((x*34.)+1.)*x,289.);}\n        vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-.85373472095314*r;}\n\n        float snoise(vec3 v){\n            const vec2 C=vec2(1./6.,1./3.);\n            const vec4 D=vec4(0.,.5,1.,2.);\n            \n            // First corner\n            vec3 i=floor(v+dot(v,C.yyy));\n            vec3 x0=v-i+dot(i,C.xxx);\n            \n            // Other corners\n            vec3 g=step(x0.yzx,x0.xyz);\n            vec3 l=1.-g;\n            vec3 i1=min(g.xyz,l.zxy);\n            vec3 i2=max(g.xyz,l.zxy);\n            \n            //  x0 = x0 - 0. + 0.0 * C\n            vec3 x1=x0-i1+1.*C.xxx;\n            vec3 x2=x0-i2+2.*C.xxx;\n            vec3 x3=x0-1.+3.*C.xxx;\n            \n            // Permutations\n            i=mod(i,289.);\n            vec4 p=permute(permute(permute(\n                i.z+vec4(0.,i1.z,i2.z,1.))\n                +i.y+vec4(0.,i1.y,i2.y,1.))\n                +i.x+vec4(0.,i1.x,i2.x,1.));\n                \n                // Gradients\n                // ( N*N points uniformly over a square, mapped onto an octahedron.)\n                float n_=1./7.;// N=7\n                vec3 ns=n_*D.wyz-D.xzx;\n                \n                vec4 j=p-49.*floor(p*ns.z*ns.z);//  mod(p,N*N)\n                \n                vec4 x_=floor(j*ns.z);\n                vec4 y_=floor(j-7.*x_);// mod(j,N)\n                \n                vec4 x=x_*ns.x+ns.yyyy;\n                vec4 y=y_*ns.x+ns.yyyy;\n                vec4 h=1.-abs(x)-abs(y);\n                \n                vec4 b0=vec4(x.xy,y.xy);\n                vec4 b1=vec4(x.zw,y.zw);\n                \n                vec4 s0=floor(b0)*2.+1.;\n                vec4 s1=floor(b1)*2.+1.;\n                vec4 sh=-step(h,vec4(0.));\n                \n                vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;\n                vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;\n                \n                vec3 p0=vec3(a0.xy,h.x);\n                vec3 p1=vec3(a0.zw,h.y);\n                vec3 p2=vec3(a1.xy,h.z);\n                vec3 p3=vec3(a1.zw,h.w);\n                \n                //Normalise gradients\n                vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));\n                p0*=norm.x;\n                p1*=norm.y;\n                p2*=norm.z;\n                p3*=norm.w;\n                \n                // Mix final noise value\n                vec4 m=max(.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.);\n                m=m*m;\n                return 42.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),\n                dot(p2,x2),dot(p3,x3)));\n            }\n            \n            vec3 snoiseVec3(vec3 x){\n                    return vec3(snoise(vec3(x)*2.-1.),\n                    snoise(vec3(x.y-19.1,x.z+33.4,x.x+47.2))*2.-1.,\n                    snoise(vec3(x.z+74.2,x.x-124.5,x.y+99.4)*2.-1.)\n                );\n            }\n        \n        vec3 curlNoise(vec3 p){\n            const float e=.1;\n            vec3 dx=vec3(e,0.,0.);\n            vec3 dy=vec3(0.,e,0.);\n            vec3 dz=vec3(0.,0.,e);\n            \n            vec3 p_x0=snoiseVec3(p-dx);\n            vec3 p_x1=snoiseVec3(p+dx);\n            vec3 p_y0=snoiseVec3(p-dy);\n            vec3 p_y1=snoiseVec3(p+dy);\n            vec3 p_z0=snoiseVec3(p-dz);\n            vec3 p_z1=snoiseVec3(p+dz);\n            \n            float x=p_y1.z-p_y0.z-p_z1.y+p_z0.y;\n            float y=p_z1.x-p_z0.x-p_x1.z+p_x0.z;\n            float z=p_x1.y-p_x0.y-p_y1.x+p_y0.x;\n            \n            const float divisor=1./(2.*e);\n            return normalize(vec3(x,y,z)*divisor);\n        }\n\n\n\n        uniform float uTime;\n        uniform float uProgress;\n        varying vec2 vUv;\n        varying vec3 vColor;\n        attribute float size;\n        attribute vec3 customColor;\n        void main(){\n            vColor = customColor;\n            vec3 noise=curlNoise(vec3(position.x*.02,position.y*.008,uTime*.05));\n            vec3 distortion=vec3(position.x*2.,position.y,1.)*noise*uProgress;\n            vec3 newPos=position+distortion;\n            vec4 modelPosition=modelMatrix*vec4(newPos,1.);\n            vec4 viewPosition=viewMatrix*modelPosition;\n            vec4 projectedPosition=projectionMatrix*viewPosition;\n            gl_Position=projectedPosition;\n            gl_PointSize=2.;\n          \n            vUv=uv;\n        }\n        ",f="\n        uniform float uTime;\n        uniform vec2 uMouse;\n        uniform vec2 uResolution;\n        uniform sampler2D pointTexture;\n    \n        varying vec2 vUv;\n        uniform vec3 color;\n        varying vec3 vColor;  \n        void main(){\n            gl_FragColor = vec4( color * vColor, 1.0 );\n        }\n    ",h=Object.freeze({uTime:{value:0},uMouse:{value:new t(0,0)},uResolution:{value:new t(600,600)},uProgress:{value:0},uTexture:{value:(new r).load("/wp5723479.png")},color:{value:new c(16777215)}});const _={name:"polygonExplosion",data(){return{curlNoise2DVertexShader:z,curlNoiseFragmentShader:f,curlNoiseUniforms:h,curl3DNoiseVertexShader:"\n       vec4 permute(vec4 x){return mod(((x*34.)+1.)*x,289.);}\n        vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-.85373472095314*r;}\n\n        float snoise(vec3 v){\n            const vec2 C=vec2(1./6.,1./3.);\n            const vec4 D=vec4(0.,.5,1.,2.);\n            \n            // First corner\n            vec3 i=floor(v+dot(v,C.yyy));\n            vec3 x0=v-i+dot(i,C.xxx);\n            \n            // Other corners\n            vec3 g=step(x0.yzx,x0.xyz);\n            vec3 l=1.-g;\n            vec3 i1=min(g.xyz,l.zxy);\n            vec3 i2=max(g.xyz,l.zxy);\n            \n            //  x0 = x0 - 0. + 0.0 * C\n            vec3 x1=x0-i1+1.*C.xxx;\n            vec3 x2=x0-i2+2.*C.xxx;\n            vec3 x3=x0-1.+3.*C.xxx;\n            \n            // Permutations\n            i=mod(i,289.);\n            vec4 p=permute(permute(permute(\n                i.z+vec4(0.,i1.z,i2.z,1.))\n                +i.y+vec4(0.,i1.y,i2.y,1.))\n                +i.x+vec4(0.,i1.x,i2.x,1.));\n                \n                // Gradients\n                // ( N*N points uniformly over a square, mapped onto an octahedron.)\n                float n_=1./7.;// N=7\n                vec3 ns=n_*D.wyz-D.xzx;\n                \n                vec4 j=p-49.*floor(p*ns.z*ns.z);//  mod(p,N*N)\n                \n                vec4 x_=floor(j*ns.z);\n                vec4 y_=floor(j-7.*x_);// mod(j,N)\n                \n                vec4 x=x_*ns.x+ns.yyyy;\n                vec4 y=y_*ns.x+ns.yyyy;\n                vec4 h=1.-abs(x)-abs(y);\n                \n                vec4 b0=vec4(x.xy,y.xy);\n                vec4 b1=vec4(x.zw,y.zw);\n                \n                vec4 s0=floor(b0)*2.+1.;\n                vec4 s1=floor(b1)*2.+1.;\n                vec4 sh=-step(h,vec4(0.));\n                \n                vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;\n                vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;\n                \n                vec3 p0=vec3(a0.xy,h.x);\n                vec3 p1=vec3(a0.zw,h.y);\n                vec3 p2=vec3(a1.xy,h.z);\n                vec3 p3=vec3(a1.zw,h.w);\n                \n                //Normalise gradients\n                vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));\n                p0*=norm.x;\n                p1*=norm.y;\n                p2*=norm.z;\n                p3*=norm.w;\n                \n                // Mix final noise value\n                vec4 m=max(.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.);\n                m=m*m;\n                return 42.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),\n                dot(p2,x2),dot(p3,x3)));\n            }\n            \n            vec3 snoiseVec3(vec3 x){\n                    return vec3(snoise(vec3(x)*2.-1.),\n                    snoise(vec3(x.y-19.1,x.z+33.4,x.x+47.2))*2.-1.,\n                    snoise(vec3(x.z+74.2,x.x-124.5,x.y+99.4)*2.-1.)\n                );\n            }\n        \n        vec3 curlNoise(vec3 p){\n            const float e=.1;\n            vec3 dx=vec3(e,0.,0.);\n            vec3 dy=vec3(0.,e,0.);\n            vec3 dz=vec3(0.,0.,e);\n            \n            vec3 p_x0=snoiseVec3(p-dx);\n            vec3 p_x1=snoiseVec3(p+dx);\n            vec3 p_y0=snoiseVec3(p-dy);\n            vec3 p_y1=snoiseVec3(p+dy);\n            vec3 p_z0=snoiseVec3(p-dz);\n            vec3 p_z1=snoiseVec3(p+dz);\n            \n            float x=p_y1.z-p_y0.z-p_z1.y+p_z0.y;\n            float y=p_z1.x-p_z0.x-p_x1.z+p_x0.z;\n            float z=p_x1.y-p_x0.y-p_y1.x+p_y0.x;\n            \n            const float divisor=1./(2.*e);\n            return normalize(vec3(x,y,z)*divisor);\n        }\n\n\n\n        uniform float uTime;\n        uniform float uProgress;\n        varying vec2 vUv;\n        varying vec3 vColor;\n        attribute float size;\n        attribute vec3 customColor;\n        void main(){\n            vColor = customColor;\n            vec3 noise=curlNoise(vec3(position.x*.02,position.y*.008,position.z*.05));\n            vec3 distortion=vec3(position.x,position.y,position.z)*noise*uProgress;\n            vec3 newPos=position+distortion;\n            vec4 modelPosition=modelMatrix*vec4(newPos,1.);\n            vec4 viewPosition=viewMatrix*modelPosition;\n            vec4 projectedPosition=projectionMatrix*viewPosition;\n            gl_Position=projectedPosition;\n            gl_PointSize=2.;\n          \n            vUv=uv;\n        }\n        ",config:{noiseValueTransitionScale:this.$d3.scaleLinear([0,1],[0,3]),clock:new s}}},mounted(){const n=this.$refs.renderer,e=this.$refs.box.mesh;e.position.set(0,0,-200);const o=e.geometry.getAttribute("position"),i=[],t=new c;for(let r=0,c=o.count;r<c;r++)t.setHSL(.01+r/c*.1,1,.5),t.toArray(i,3*r);e.geometry.setAttribute("customColor",new v(i,3)),n.onBeforeRender((()=>{e.rotation.x+=.01})),setTimeout((()=>{this.dispatchActivateExplosionEffect(e)}),2e3)},methods:{async dispatchActivateExplosionEffect(n){let e=n;await this.$d3.transition("activate-explosion").duration(3e3).tween("render",(()=>n=>{e.material.uniforms.uProgress.value=this.config.noiseValueTransitionScale(n)})).transition("shrink-explosion").tween("render",(()=>n=>{e.material.uniforms.uProgress.value=this.config.noiseValueTransitionScale(1-n)})).end()}}};_.render=function(t,r,c,s,v,a){const p=n("Camera"),l=n("PointLight"),d=n("BoxGeometry"),y=n("ShaderMaterial"),u=n("Points"),m=n("Scene"),z=n("Renderer");return e(),o(z,{ref:"renderer",antialias:"",resize:"window","orbit-ctrl":""},{default:x((()=>[i(p,{position:{z:10}}),i(m,null,{default:x((()=>[i(l,{position:{y:50,z:50,x:25}}),i(u,{onClick:a.dispatchActivateExplosionEffect,ref:"box",rotation:{y:Math.PI/4,z:Math.PI/4}},{default:x((()=>[i(d,{width:100,height:100,depth:100,widthSegments:100,heightSegments:100,depthSegments:100}),i(y,{props:{vertexShader:v.curl3DNoiseVertexShader,uniforms:v.curlNoiseUniforms,fragmentShader:v.curlNoiseFragmentShader}},null,8,["props"])])),_:1},8,["onClick","rotation"])])),_:1})])),_:1},512)};const g={name:"planeExplosion",data(){return{particleExplodeFragmentShader:"\nuniform float uTime;\nuniform vec2 uMouse;\nuniform vec2 uResolution;\nuniform sampler2D uTexture;\n\nvarying vec2 vUv;\n\nvoid main(){\n    vec4 color=texture2D(uTexture,vUv);\n    if(color.r<.1&&color.g<.1&&color.b<.1){\n        discard;\n    }\n    gl_FragColor=color;\n}\n",particleExplodeVertexShader:"\nvec4 permute(vec4 x){return mod(((x*34.)+1.)*x,289.);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159-.85373472095314*r;}\n\nfloat snoise(vec3 v){\n    const vec2 C=vec2(1./6.,1./3.);\n    const vec4 D=vec4(0.,.5,1.,2.);\n    \n    // First corner\n    vec3 i=floor(v+dot(v,C.yyy));\n    vec3 x0=v-i+dot(i,C.xxx);\n    \n    // Other corners\n    vec3 g=step(x0.yzx,x0.xyz);\n    vec3 l=1.-g;\n    vec3 i1=min(g.xyz,l.zxy);\n    vec3 i2=max(g.xyz,l.zxy);\n    \n    //  x0 = x0 - 0. + 0.0 * C\n    vec3 x1=x0-i1+1.*C.xxx;\n    vec3 x2=x0-i2+2.*C.xxx;\n    vec3 x3=x0-1.+3.*C.xxx;\n    \n    // Permutations\n    i=mod(i,289.);\n    vec4 p=permute(permute(permute(\n                i.z+vec4(0.,i1.z,i2.z,1.))\n                +i.y+vec4(0.,i1.y,i2.y,1.))\n                +i.x+vec4(0.,i1.x,i2.x,1.));\n                \n                // Gradients\n                // ( N*N points uniformly over a square, mapped onto an octahedron.)\n                float n_=1./7.;// N=7\n                vec3 ns=n_*D.wyz-D.xzx;\n                \n                vec4 j=p-49.*floor(p*ns.z*ns.z);//  mod(p,N*N)\n                \n                vec4 x_=floor(j*ns.z);\n                vec4 y_=floor(j-7.*x_);// mod(j,N)\n                \n                vec4 x=x_*ns.x+ns.yyyy;\n                vec4 y=y_*ns.x+ns.yyyy;\n                vec4 h=1.-abs(x)-abs(y);\n                \n                vec4 b0=vec4(x.xy,y.xy);\n                vec4 b1=vec4(x.zw,y.zw);\n                \n                vec4 s0=floor(b0)*2.+1.;\n                vec4 s1=floor(b1)*2.+1.;\n                vec4 sh=-step(h,vec4(0.));\n                \n                vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;\n                vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;\n                \n                vec3 p0=vec3(a0.xy,h.x);\n                vec3 p1=vec3(a0.zw,h.y);\n                vec3 p2=vec3(a1.xy,h.z);\n                vec3 p3=vec3(a1.zw,h.w);\n                \n                //Normalise gradients\n                vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));\n                p0*=norm.x;\n                p1*=norm.y;\n                p2*=norm.z;\n                p3*=norm.w;\n                \n                // Mix final noise value\n                vec4 m=max(.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.);\n                m=m*m;\n                return 42.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),\n                dot(p2,x2),dot(p3,x3)));\n            }\n            \n            vec3 snoiseVec3(vec3 x){\n                return vec3(snoise(vec3(x)*2.-1.),\n                snoise(vec3(x.y-19.1,x.z+33.4,x.x+47.2))*2.-1.,\n                snoise(vec3(x.z+74.2,x.x-124.5,x.y+99.4)*2.-1.)\n            );\n        }\n        \n        vec3 curlNoise(vec3 p){\n            const float e=.1;\n            vec3 dx=vec3(e,0.,0.);\n            vec3 dy=vec3(0.,e,0.);\n            vec3 dz=vec3(0.,0.,e);\n            \n            vec3 p_x0=snoiseVec3(p-dx);\n            vec3 p_x1=snoiseVec3(p+dx);\n            vec3 p_y0=snoiseVec3(p-dy);\n            vec3 p_y1=snoiseVec3(p+dy);\n            vec3 p_z0=snoiseVec3(p-dz);\n            vec3 p_z1=snoiseVec3(p+dz);\n            \n            float x=p_y1.z-p_y0.z-p_z1.y+p_z0.y;\n            float y=p_z1.x-p_z0.x-p_x1.z+p_x0.z;\n            float z=p_x1.y-p_x0.y-p_y1.x+p_y0.x;\n            \n            const float divisor=1./(2.*e);\n            return normalize(vec3(x,y,z)*divisor);\n        }\n        \n        uniform float uTime;\n        uniform float uProgress;\n        varying vec2 vUv;\n        \n        void main(){\n            vec3 noise=curlNoise(vec3(position.x*.02,position.y*.008,uTime*.05));\n            vec3 distortion=vec3(position.x*2.,position.y,1.)*noise*uProgress;\n            vec3 newPos=position+distortion;\n            vec4 modelPosition=modelMatrix*vec4(newPos,1.);\n            vec4 viewPosition=viewMatrix*modelPosition;\n            vec4 projectedPosition=projectionMatrix*viewPosition;\n            gl_Position=projectedPosition;\n            gl_PointSize=2.;\n            \n            vUv=uv;\n        }\n",curlNoiseUniforms:h,curlNoise2DVertexShader:z,curlNoiseFragmentShader:f,config:{noiseValueTransitionScale:this.$d3.scaleLinear([0,1],[0,3]),clock:new s}}},mounted(){this.$refs.renderer;const n=this.$refs.box.mesh;n.position.set(0,0,-1e3);const e=n.geometry.getAttribute("position"),o=[],i=new c;for(let t=0,r=e.count;t<r;t++)i.setHSL(.01+t/r*.1,1,.5),i.toArray(o,3*t);n.geometry.setAttribute("customColor",new v(o,3)),setTimeout((()=>{this.dispatchActivateExplosionEffect(n)}),2e3)},methods:{async dispatchActivateExplosionEffect(n){let e=n;await this.$d3.transition("activate-explosion").duration(3e3).tween("render",(()=>n=>{e.material.uniforms.uProgress.value=this.config.noiseValueTransitionScale(n),e.material.uniforms.uTime.value=this.config.clock.getElapsedTime()})).transition("shrink-explosion").tween("render",(()=>n=>{e.material.uniforms.uProgress.value=this.config.noiseValueTransitionScale(1-n),e.material.uniforms.uTime.value=this.config.clock.getElapsedTime()})).end()}}};g.render=function(t,r,c,s,v,a){const p=n("Camera"),l=n("PointLight"),d=n("PlaneGeometry"),y=n("ShaderMaterial"),u=n("Points"),m=n("Scene"),z=n("Renderer");return e(),o("div",null,[i(z,{ref:"renderer",antialias:"",resize:"window","orbit-ctrl":""},{default:x((()=>[i(p,{position:{z:10}}),i(m,null,{default:x((()=>[i(l,{position:{y:50,z:50,x:25}}),i(u,{onClick:a.dispatchActivateExplosionEffect,ref:"box"},{default:x((()=>[i(d,{width:1770,height:1e3,widthSegments:50,heightSegments:50}),i(y,{props:{vertexShader:v.particleExplodeVertexShader,uniforms:v.curlNoiseUniforms,fragmentShader:v.particleExplodeFragmentShader}},null,8,["props"])])),_:1},8,["onClick"])])),_:1})])),_:1},512)])};var w=[{path:"/polygonExplosion",component:_},{path:"/planeExplosion",component:g}];const P=a({history:p(),routes:w}),b=l(m);b.use(P),b.use(d),b.mount("#app"),b.config.globalProperties.$d3=y,b.config.globalProperties.lodash=u;
